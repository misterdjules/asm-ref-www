<!DOCTYPE html>
<html></html>
<script type="text/javascript" src="/vendor/bower_components/jquery/jquery.js"></script>
<script type="text/javascript" src="/vendor/bower_components/typeahead.js/dist/bloodhound.js"></script>
<script type="text/javascript" src="/vendor/bower_components/typeahead.js/dist/typeahead.jquery.js"></script>
<script type="text/javascript" src="/scripts/autocomplete.js"></script>
<link rel="stylesheet" href="/vendor/bower_components/bootstrap/dist/css/bootstrap.css">
<link rel="stylesheet" href="/typeahead.css">
<input id="search" type="text" placeholder="Mnemonic" class="typeahead">
<h1>MOVDQU -- Move Unaligned Double Quadword</h1>
<h2>Short description</h2>
<p> 128-bit versions: Moves 128 bits of packed integer values from the source operand (second operand) to the destination operand (first operand).</p>
<h2>Long description</h2>
<p> 128-bit versions: Moves 128 bits of packed integer values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM register from a 128-bit memory location, to store the contents of an XMM register into a 128-bit memory location, or to move data between two XMM registers. When the source or destination operand is a memory operand, the operand may be unaligned on a 16-byte boundary without causing a general-protection exception (#GP) to be generated.1 To move a double quadword to or from memory locations that are known to be aligned on 16-byte boundaries, use the MOVDQA instruction. While executing in 16-bit addressing mode, a linear address for a 128-bit data access that overlaps the end of a 16bit segment is not allowed and is defined as reserved behavior. A specific processor implementation may or may not generate a general-protection exception (#GP) in this situation, and the address that spans the end of the segment may or may not wrap around to the beginning of the segment. In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15). 128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged. When the source or destination operand is a memory operand, the operand may be unaligned to any alignment without causing a general-protection exception (#GP) to be generated VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed. VEX.256 encoded version: Moves 256 bits of packed integer values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a YMM register from a 256-bit memory 1. If alignment checking is enabled (CR0.AM = 1, RFLAGS.AC = 1, and CPL = 3), an alignment-check exception (#AC) may or may not be generated (depending on processor implementation) when the operand is not aligned on an 8-byte boundary. 3-528 Vol. 2A</p>
<h2>Affected flags</h2>
<p></p>
<script type="text/javascript">window.onload = function () { initTypeAhead(); }</script>